Proje MantÄ±ÄŸÄ± ve Sunumda AnlatÄ±lacaklar
1. Projenin AmacÄ±
Bu proje, temel bir IRC (Internet Relay Chat) sunucusudur.
KullanÄ±cÄ±lar belirli bir port Ã¼zerinden sunucuya baÄŸlanÄ±p, kanallar oluÅŸturabilir ve mesajlaÅŸabilir.
2. Temel BileÅŸenler
main.cpp: UygulamanÄ±n giriÅŸ noktasÄ±. Port ve ÅŸifreyi alÄ±r, sunucuyu baÅŸlatÄ±r.
Server.hpp/cpp: Sunucunun ana iÅŸlevlerini ve baÄŸlantÄ± yÃ¶netimini iÃ§erir.
Client, Channel, Poller, Router: Her biri IRC protokolÃ¼nÃ¼n farklÄ± bir yÃ¶nÃ¼nÃ¼ yÃ¶netir (kullanÄ±cÄ±, kanal, olay dÃ¶ngÃ¼sÃ¼, komut yÃ¶nlendirme).
3. Sunucunun Ã‡alÄ±ÅŸma MantÄ±ÄŸÄ±
Sunucu baÅŸlatÄ±lÄ±rken port ve ÅŸifre parametreleriyle kurulur.
Sinyal yakalama ile (Ã¶rn. Ctrl+C) dÃ¼zgÃ¼n kapanma saÄŸlanÄ±r.
Sunucu, yeni istemcileri kabul eder, her istemciyi bir Client nesnesi olarak saklar.
Her istemciden gelen veriler okunur, satÄ±r satÄ±r ayrÄ±lÄ±r ve Router ile ilgili komutlar iÅŸlenir.
Kanallar dinamik olarak oluÅŸturulur ve yÃ¶netilir.
Mesajlar, ilgili kanallara veya istemcilere iletilir.
4. Ã–nemli Fonksiyonlar
Server::run(): Olay dÃ¶ngÃ¼sÃ¼nÃ¼ yÃ¶netir, baÄŸlantÄ± ve veri akÄ±ÅŸÄ±nÄ± kontrol eder.
handleAccept(), handleReadable(), handleWritable(): BaÄŸlantÄ± kabulÃ¼, veri okuma/yazma iÅŸlemlerini yÃ¶netir.
broadcastToChannel(), sendToClient(): Mesaj iletimini saÄŸlar.
Sunumda KullanabileceÄŸin KonuÅŸma Metni (Ã–rnek)
Merhaba, ben bu projede temel bir IRC sunucusu geliÅŸtirdim. Projenin amacÄ±, istemcilerin bir sunucuya baÄŸlanÄ±p, kanallar Ã¼zerinden birbirleriyle gerÃ§ek zamanlÄ± olarak mesajlaÅŸabilmesini saÄŸlamak.

Projenin ana dosyasÄ± olan main.cpp, uygulamanÄ±n giriÅŸ noktasÄ±dÄ±r. Burada port ve ÅŸifre parametreleri alÄ±nÄ±r ve sunucu baÅŸlatÄ±lÄ±r. Sunucu, sinyal yakalama mekanizmasÄ± sayesinde Ctrl+C gibi kesintilerde dÃ¼zgÃ¼n bir ÅŸekilde kapanabiliyor.

Sunucunun kalbi ise Server sÄ±nÄ±fÄ±. Burada baÄŸlantÄ± kabulÃ¼, istemci yÃ¶netimi, kanal oluÅŸturma ve mesaj iletimi gibi tÃ¼m temel iÅŸlevler yer alÄ±yor. Her yeni baÄŸlantÄ± bir Client nesnesi olarak saklanÄ±yor ve bu istemciler kanallara katÄ±labiliyor.

Veri akÄ±ÅŸÄ± ve olay yÃ¶netimi iÃ§in bir Poller sÄ±nÄ±fÄ± kullanÄ±lÄ±yor. Bu sayede sunucu, aynÄ± anda birden fazla istemciyle verimli ÅŸekilde iletiÅŸim kurabiliyor.

Mesajlar, ilgili kanallara veya doÄŸrudan istemcilere iletiliyor. Kanallar dinamik olarak oluÅŸturuluyor ve boÅŸaldÄ±klarÄ±nda otomatik olarak siliniyor.

KÄ±sacasÄ±, bu proje ile temel bir IRC sunucusunun nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ±, istemci ve kanal yÃ¶netiminin nasÄ±l yapÄ±ldÄ±ÄŸÄ±nÄ± ve gerÃ§ek zamanlÄ± mesajlaÅŸmanÄ±n arka planda nasÄ±l organize edildiÄŸini gÃ¶stermiÅŸ oldum.

Sunumda Ã¶zellikle:

Projenin amacÄ±nÄ±,
Temel dosya ve sÄ±nÄ±flarÄ±,
Olay dÃ¶ngÃ¼sÃ¼nÃ¼ ve istemci/kanal yÃ¶netimini,
MesajlaÅŸma mantÄ±ÄŸÄ±nÄ±,
Kendi katkÄ±larÄ±nÄ± ve Ã¶ÄŸrendiklerini

IRC NotlarÄ±nÄ±n Ã–zeti
Genel Eksikler ve Hatalar
Kanal modlarÄ± (+i, +k, +l, +t) tanÄ±mlanmÄ±ÅŸ ama kullanÄ±lmÄ±yor; bu modlar eksikse puan kaybÄ± olur.
Prefix formatÄ± (nick!user@host) doÄŸru deÄŸil, IP yerine hostname olmalÄ±.
Port ve input kontrolleri yetersiz; negatif port veya overflow kontrolÃ¼ yok.
Parser ve komut yÃ¶nlendirme (Router) kÄ±smÄ±nda trailing parametreler ve mesaj birleÅŸtirme hatalÄ±; uzun mesajlar veya Ã§ok kelimeli mesajlar yanlÄ±ÅŸ parse ediliyor.
Pollerâ€™da boÅŸ vektÃ¶rle poll Ã§aÄŸrÄ±sÄ± UB (undefined behavior) riski var.
Error handling, memory/fd leak kontrolleri ve gÃ¼venlik (input sanitize) eksik.
KomutlarÄ±n (MODE, TOPIC, KICK, PART, QUIT, NICK change) Ã§oÄŸu eksik veya hatalÄ±.
Numerics (001, 421, vs.) ve cevap formatlarÄ± RFCâ€™ye tam uyumlu deÄŸil.
SÄ±nÄ±flarÄ±n AmaÃ§larÄ±
Channel: Kanal Ã¼yeleri, operatorler, davetliler ve modlar tutulur. Ãœye ekleme/Ã§Ä±karma, op atama, davet sistemi gibi iÅŸlemler yapÄ±lÄ±r.
Client: Her kullanÄ±cÄ±ya ait baÄŸlantÄ±, nick, user, kanallar, okuma/yazma bufferâ€™larÄ± ve kimlik doÄŸrulama durumu tutulur.
Parser: IRC satÄ±rÄ±nÄ± prefix, komut ve parametrelerine ayÄ±rÄ±r. Trailing parametrelerde ve boÅŸluklu mesajlarda eksikler var.
Poller: poll() ile Ã§oklu soketleri yÃ¶netir. add/modify/remove ile fdâ€™leri ekler/Ã§Ä±karÄ±r, wait ile poll Ã§aÄŸrÄ±sÄ± yapar.
Router: Gelen mesajÄ± uygun handlerâ€™a yÃ¶nlendirir. KomutlarÄ±n Ã§oÄŸu burada iÅŸlenir, ama parametre birleÅŸtirme ve formatlarda eksikler var.
Server: Socket aÃ§ma, accept, read, write, client ve kanal yÃ¶netimi burada yapÄ±lÄ±r.
AkÄ±ÅŸ ve MantÄ±k
Sunucu bir TCP dinleyici aÃ§ar, poll() ile Ã§oklu soketleri izler.
Yeni baÄŸlantÄ± gelince Client nesnesi oluÅŸturulur.
Gelen veriler bufferâ€™a eklenir, satÄ±r tamamlanÄ±nca Parser ile ayrÄ±ÅŸtÄ±rÄ±lÄ±r.
Router, komutu iÅŸler ve gerekirse mesajÄ± kanala veya kullanÄ±cÄ±ya iletir.
Ã‡Ä±kÄ±ÅŸ kuyruÄŸundaki mesajlar handleWritable ile gÃ¶nderilir.
Dikkat Edilmesi Gerekenler ve HÄ±zlÄ± Ã‡Ã¶zÃ¼mler
Komutlarda parametre birleÅŸtirme (Ã¶zellikle PRIVMSG ve TOPIC) yapÄ±lmalÄ±.
std::toupper kullanÄ±mÄ± gÃ¼venli cast ile yapÄ±lmalÄ±.
poll() Ã§aÄŸrÄ±sÄ± boÅŸ vektÃ¶rde gÃ¼venli olmalÄ±.
Router dÃ¶ngÃ¼ dÄ±ÅŸÄ±nda oluÅŸturulmalÄ±, sÃ¼rekli yeniden yaratÄ±lmamalÄ±.
Auth akÄ±ÅŸÄ± (PASS, NICK, USER) tamamlanmadan kullanÄ±cÄ±ya komut izni verilmemeli.
Numerics ve cevap formatlarÄ± RFCâ€™ye uygun olmalÄ±.
Partial send ve socket kapanÄ±ÅŸlarÄ±nda dikkatli olunmalÄ±

1. Silinen KanalÄ±n Eski MesajlarÄ±nÄ±n GÃ¶rÃ¼nmesi
Senin sunucunda, bir kanal boÅŸaldÄ±ÄŸÄ±nda (yani tÃ¼m kullanÄ±cÄ±lar ayrÄ±ldÄ±ÄŸÄ±nda) kanal nesnesi sunucudan siliniyor. Ancak, IRC istemcileri (Ã¶r. HexChat, mIRC, irssi gibi) kendi taraflarÄ±nda kanal geÃ§miÅŸini tutabiliyorlar. Yani:

Sunucu, kanal silindiÄŸinde o kanalÄ±n mesajlarÄ±nÄ± veya geÃ§miÅŸini saklamaz.
Fakat istemci programÄ±, kullanÄ±cÄ± kanaldayken aldÄ±ÄŸÄ± mesajlarÄ± kendi arayÃ¼zÃ¼nde tutar ve kullanÄ±cÄ± tekrar aynÄ± kanala girerse eski mesajlarÄ± hÃ¢lÃ¢ gÃ¶rebilir.
Bu, sunucu tarafÄ±nda bir â€œmesaj geÃ§miÅŸiâ€ saklanmadÄ±ÄŸÄ±, sadece istemcinin kendi Ã¶nbelleÄŸinde tuttuÄŸu anlamÄ±na gelir.
Yani, kanal silinse bile, istemci programÄ± eski mesajlarÄ± gÃ¶sterebilir Ã§Ã¼nkÃ¼ bu mesajlar istemcinin belleÄŸinde tutulur, sunucudan tekrar alÄ±nmaz.

2. Poller SÄ±nÄ±fÄ± ve Olay YÃ¶netimi (DetaylÄ± AÃ§Ä±klama)
Poller sÄ±nÄ±fÄ±, sunucunun aynÄ± anda birden fazla istemciyle verimli ÅŸekilde iletiÅŸim kurmasÄ±nÄ± saÄŸlar. Bunu ÅŸÃ¶yle anlatabilirsin:

Poller sÄ±nÄ±fÄ±, sunucunun Ã§oklu istemci baÄŸlantÄ±larÄ±nÄ± yÃ¶netebilmesi iÃ§in â€œI/O multiplexingâ€ (girdi/Ã§Ä±ktÄ± Ã§oklama) tekniÄŸini kullanÄ±r. Yani, sunucuya birden fazla istemci baÄŸlandÄ±ÄŸÄ±nda, her bir istemci iÃ§in ayrÄ± bir iÅŸ parÃ§acÄ±ÄŸÄ± (thread) aÃ§mak yerine, tek bir ana dÃ¶ngÃ¼de tÃ¼m istemcilerin baÄŸlantÄ±larÄ±nÄ± izler.

Poller, sistemin â€œpollâ€ veya â€œselectâ€ gibi fonksiyonlarÄ±nÄ± kullanarak, hangi istemciden veri geldiÄŸini, hangisine veri gÃ¶nderilebileceÄŸini veya hangi baÄŸlantÄ±nÄ±n kapandÄ±ÄŸÄ±nÄ± tespit eder. BÃ¶ylece:

Sunucu, binlerce istemciyle aynÄ± anda, hÄ±zlÄ± ve verimli ÅŸekilde iletiÅŸim kurabilir.
Her istemciden gelen veri, olay tabanlÄ± olarak iÅŸlenir. Yani veri geldiÄŸinde veya gÃ¶nderilecek veri olduÄŸunda Poller bunu algÄ±lar ve ilgili fonksiyonlarÄ± tetikler.
Bu yÃ¶ntem, kaynak tÃ¼ketimini azaltÄ±r ve sunucunun Ã¶lÃ§eklenebilirliÄŸini artÄ±rÄ±r.
KÄ±sacasÄ±, Poller sÄ±nÄ±fÄ± sayesinde sunucu, Ã§ok sayÄ±da istemciyle tek bir ana dÃ¶ngÃ¼de, yÃ¼ksek performansla ve verimli ÅŸekilde Ã§alÄ±ÅŸabiliyor

1. Sunucunun BaÅŸlatÄ±lmasÄ±
Sunucuyu baÅŸlatmak iÃ§in Ã¶ncelikle main.cpp dosyasÄ±nda, komut satÄ±rÄ±ndan port ve ÅŸifre parametreleri alÄ±nÄ±yor. Bu parametrelerle bir Server nesnesi oluÅŸturuluyor ve server.run() fonksiyonu Ã§aÄŸrÄ±larak sunucu baÅŸlatÄ±lÄ±yor.

2. Socket OluÅŸturma ve Dinleme
Server sÄ±nÄ±fÄ±nÄ±n kurucusunda (Server::Server), Ã¶nce bir socket oluÅŸturuluyor:

socket(AF_INET, SOCK_STREAM, 0) ile TCP tabanlÄ± bir socket aÃ§Ä±lÄ±yor.
setsockopt ile adresin tekrar kullanÄ±labilmesi saÄŸlanÄ±yor.
setNonBlocking fonksiyonu ile socket non-blocking moda alÄ±nÄ±yor, bÃ¶ylece sunucu tek bir dÃ¶ngÃ¼de tÃ¼m istemcileri yÃ¶netebiliyor.
bind fonksiyonu ile socket, verilen port numarasÄ±na baÄŸlanÄ±yor.
listen fonksiyonu ile socket dinlemeye baÅŸlÄ±yor ve gelen baÄŸlantÄ±lar kabul edilmeye hazÄ±r hale geliyor.
3. BaÄŸlantÄ±larÄ±n KabulÃ¼
Sunucu ana dÃ¶ngÃ¼sÃ¼nde (Server::run), Poller ile yeni baÄŸlantÄ± olup olmadÄ±ÄŸÄ± sÃ¼rekli kontrol ediliyor. EÄŸer yeni bir baÄŸlantÄ± gelirse, handleAccept() fonksiyonu Ã§aÄŸrÄ±lÄ±yor ve:

accept ile yeni istemci baÄŸlantÄ±sÄ± kabul ediliyor.
Her yeni istemci iÃ§in bir Client nesnesi oluÅŸturuluyor ve pollerâ€™a ekleniyor.
4. Sunucunun Sunucu OlmasÄ±nÄ± SaÄŸlayan Temel Noktalar
Socket aÃ§Ä±lmasÄ± ve dinlemeye alÄ±nmasÄ±
Non-blocking yapÄ± ile Ã§oklu istemci desteÄŸi
Poller ile olay tabanlÄ± yÃ¶netim
Her istemci iÃ§in ayrÄ± nesne ve kanal yÃ¶netimi
Sunumda ÅÃ¶yle Anlatabilirsin:
Sunucunun aÃ§Ä±lÄ±ÅŸÄ±nda, Ã¶ncelikle bir TCP socket oluÅŸturup, bunu belirlediÄŸimiz port numarasÄ±na baÄŸlÄ±yoruz. ArdÄ±ndan, bu socketâ€™i dinlemeye alÄ±yoruz. Sunucu, Poller sÄ±nÄ±fÄ± sayesinde sÃ¼rekli olarak yeni baÄŸlantÄ± olup olmadÄ±ÄŸÄ±nÄ± ve mevcut istemcilerden veri gelip gelmediÄŸini kontrol ediyor. Yeni bir baÄŸlantÄ± geldiÄŸinde, bu baÄŸlantÄ± kabul edilip bir istemci nesnesi olarak sisteme ekleniyor. BÃ¶ylece, sunucu aynÄ± anda birden fazla istemciyle iletiÅŸim kurabiliyor ve gerÃ§ek bir IRC sunucusu gibi davranabiliyor.


1. Channel.cpp

removeMember:

_ops.erase(fd); _invited.erase(fd); direkt Ã§aÄŸÄ±rÄ±yorsun ama fd zaten o setlerde olmayabilir. Ã‡Ã¶kmez ama â€œgereksiz eraseâ€ Ã§aÄŸrÄ±larÄ± var. Ufak overhead.

isMember:

For dÃ¶ngÃ¼sÃ¼nde tek satÄ±rda hem arama hem return yapmÄ±ÅŸsÄ±n. Kod okunabilirliÄŸi dÃ¼ÅŸÃ¼yor. std::find kullanmak daha temiz olurdu.

Eksik kÄ±sÄ±m: _limit, _modeI, _modeT, _modeK, _modeL tanÄ±mlanmÄ±ÅŸ ama hiÃ§ kullanÄ±lmÄ±yor. Bu server kanal modlarÄ±nÄ± desteklemiyor demek. EÄŸer 42â€™nin irc projesi iÃ§in yapÄ±yorsan, kesin eksi puan alÄ±rsÄ±n Ã§Ã¼nkÃ¼ +i, +k, +l, +t modlarÄ±nÄ± implemente etmen lazÄ±m.

2. Client.cpp

getPrefix:

IRC standardÄ±nda prefix formatÄ± nick!user@host. Sen _ip koyuyorsun host yerine. Bu Ã§alÄ±ÅŸÄ±r ama doÄŸru deÄŸil, testlerde yakalanabilir. Normalde DNS host resolve etmen gerekir (hostname lookup).

consumeWrite:

if (_wq.empty()) return; diyorsun ama sonra if (n >= _wq.front().size()) { _wq.erase(...) }. Burada partial send mantÄ±ÄŸÄ± var ama edge-case: send() mesela 0 dÃ¶nerse, sen consumeWrite(0) Ã§aÄŸÄ±rabilirsin â†’ bu durumda _wq.front().erase(0,0) yapÄ±yor, harmless ama gereksiz.

leaveChannel:

AynÄ± pattern: loop + erase. std::remove + erase daha temiz.

3. Server main

isNumber:

isdigit â†’ #include <cctype> lazÄ±m (ama ÅŸu an <cstdlib> var). Derleyicide warning verebilir.

Port iÃ§in atoi kullanÄ±yorsun, negative veya overflow check yok. EÄŸer atoi("-1") olursa â†’ port = -1 olur ve Server ctorâ€™una girer, undefined davranÄ±ÅŸa gidersin. GÃ¼venlik aÃ§Ä±ÄŸÄ±.

4. Parser.cpp

parse:

Ã‡ok kritik: IRC mesaj formatÄ± [:prefix] command [params] [:trailing]. Sen trailing kÄ±smÄ± alÄ±yorsun ama prefix parsing zayÄ±f. Ã–rneÄŸin :nick!user@host COMMAND arg1 :some text formatÄ±nda test et, kesin kÄ±rÄ±lÄ±r.

trim ile parametrelerin baÅŸÄ±ndaki boÅŸluklarÄ± atÄ±yorsun, ama RFC 1459â€™da parametrelerin ortasÄ±nda boÅŸluk varsa trailing kÄ±smÄ±na kaydÄ±rÄ±lmasÄ± lazÄ±m. Sen onu yapmÄ±yorsun. Yani "PRIVMSG #chan :hello world" doÄŸru parse edilmez â†’ params ["#chan", "hello world"] olmalÄ±. Åu an "hello world"â€™Ã¼ yanlÄ±ÅŸ kÄ±rabilirsin.

5. Poller.cpp

wait:

poll(ptr, n, timeoutMs) â†’ burada ptr = &_pfds[0]. Ama _pfds boÅŸsa &_pfds[0] undefined behavior. Sen ? (struct pollfd*)0 yapmÄ±ÅŸsÄ±n ama sonra poll(0,0,timeout) Ã§aÄŸÄ±rÄ±yorsun. Bu POSIXâ€™te valid, ama NULL pointer geÃ§mek UB olabilir. Daha gÃ¼venli:

return _pfds.empty() ? 0 : poll(&_pfds[0], _pfds.size(), timeoutMs);


isReadable / isWritable:

DÃ¶ngÃ¼den erken return etmen daha iyi. Åu an for iÃ§inde if + return var, ama readability dÃ¼ÅŸÃ¼k.

Genel eksikler

Error handling yok: hiÃ§bir yerde exception atÄ±lmÄ±yor (Ã¶rn. Parser::parse yanlÄ±ÅŸ formatta input alÄ±rsa).

Memory / fd leaks kontrol edilmiyor.

Mode, Topic, Kick, Part, Quit, Nick change gibi komutlarÄ±n implementasyonu yok â†’ bu haliyle sadece baÄŸlantÄ± kabul eder, ama gerÃ§ek bir IRC server gibi davranmaz.

Security: input sanitize zayÄ±f. KullanÄ±cÄ± nicklerinde boÅŸluk veya Ã¶zel karakter test edilmemiÅŸ.

1. Router.cpp (komut yÃ¶nlendirme)

Command uppercase â†’ for (size_t i = 0; i < m.command.size(); ++i) m.command[i] = std::toupper(m.command[i]);
Burada std::toupper aslÄ±nda int dÃ¶ner ve unsigned char bekler. Lokalizationâ€™a gÃ¶re undefined behavior Ã§Ä±kabilir. m.command[i] = std::toupper((unsigned char)m.command[i]); diye dÃ¼zelt.

USER kaydÄ± â†’ if (!c->isPassOk()) { ... } else if (c->authed()) { ... }
Burada authed() kontrolÃ¼nÃ¼ PASS, NICK, USER Ã¼Ã§lÃ¼sÃ¼ tamamlandÄ±ÄŸÄ±nda tetiklemek lazÄ±m. Yoksa adam PASSâ€™i atlarsa, nick/userâ€™Ä± setlenip ama asla 001 welcome dÃ¶nmeyebilir.

PRIVMSG / NOTICE â†’ std::string text = m.params[1];
Burada sadece ilk parametreyi alÄ±yorsun. Halbuki IRC protokolÃ¼nde mesajÄ±n geri kalanÄ± :<mesajÄ±n tamamÄ±> olabilir. Yani "PRIVMSG #chan :selam millet nasÄ±lsÄ±nÄ±z" geldiÄŸinde sen sadece "selam" gÃ¶receksin. join(m.params.begin()+1, m.params.end()) gibi birleÅŸtirme yapman lazÄ±m.

TOPIC â†’ aynÄ± problem, sadece m.params[1] alÄ±yorsun ama :<uzun topic> geldiÄŸinde tek kelime kalÄ±r.

INVITE â†’ _s->sendToClient(dst->getFd(), crlf(":ircserv INVITE " + nick + " :" + chan));
Normalde prefix gÃ¶ndermen gerek: :<inviter_nick>!user@host INVITE target_nick :#chan. Sen kendi server nickâ€™i gibi dÃ¶nÃ¼yorsun â†’ bazÄ± clientâ€™lar bunu kabul etmez.

MODE â†’ Ã§ok kaba implementasyon var. Parametre parsing sÄ±kÄ±ntÄ±lÄ± (Ã¶rn. +k iÃ§in parametre lazÄ±m ama yoksa crash). AyrÄ±ca o modeâ€™da: _s->findClientByNick(m.params[pidx++]) yoksa segmentation. BurayÄ± sÄ±kÄ±laÅŸtÄ±rman ÅŸart.

General â†’ Unknown command iÃ§in 421 dÃ¶ndÃ¼rmen gÃ¼zel ama <nick> <command> formatÄ±nÄ± eksik gÃ¶nderiyorsun. RFCâ€™de 421 ÅŸu ÅŸekilde: :server 421 <nick> <command> :Unknown command.

2. Server.cpp (socket + poller)

IPv6/IPv4 fallback mantÄ±klÄ± ama bind hata durumlarÄ±nÄ± daha aÃ§Ä±k loglamak iyi olur. Åu an bind() failed deyip bÄ±rakÄ±yorsun.

handleAccept â†’ dÃ¶ngÃ¼de accept sonrasÄ± _poller->add(cfd, POLLIN); yapÄ±yorsun. Ama POLLHUP, POLLERR gibi ÅŸeyleri de eklemen lazÄ±m yoksa bazÄ± durumlar kaÃ§abilir.

addClient â†’ ÅŸimdilik sadece NOTICE * :Welcome atÄ±yorsun. Ama RFCâ€™ye gÃ¶re 001, 002, 003, 004 gibi welcome numerics dÃ¶ndÃ¼rmen gerek. Yoksa HexChat/irssi gibi clientâ€™lar â€œbaÄŸlandÄ±m ama register olmadÄ±mâ€ diye takÄ±lÄ±r.

removeClient â†’ ÅŸu an kanallardan Ã§Ä±karken broadcastToChannel(... "PART ...") gÃ¶nderiyorsun ama QUIT eventâ€™i asÄ±l gerekli. Client kapanÄ±yorsa, diÄŸerleri :<nick> QUIT :reason gÃ¶rmeli.

handleReadable â†’ Router router(this); her satÄ±r iÃ§in yeni Router instance oluÅŸturuyorsun. Bu gereksiz. Router zaten server pointer tutuyor, bir kere oluÅŸturup loop boyunca reuse et. Yoksa overhead.

handleWritable â†’ incomplete: dosya sonu kesilmiÅŸ. Ama dikkat: sen send() ile tÃ¼m bufferâ€™Ä± gÃ¶nderemezsen (EAGAIN, short write) halinde bufferâ€™Ä± kÄ±rpÄ±p kalanÄ±nÄ± sÄ±rada bÄ±rakman lazÄ±m. Yoksa mesajlar eksik gider.

3. Genel riskler

Line parsing â†’ IRC mesajlarÄ± \r\n ile biter. Client \n atarsa, senin parserâ€™Ä±nda sorun olabilir.

Thread safety yok â†’ tek poller thread Ã§alÄ±ÅŸÄ±yor, tamam, ama dikkat: _clients map Ã¼zerinde remove sÄ±rasÄ±nda iterator invalidation olabilir.

UTF-8 / nickname validation yok â†’ RFCâ€™ye gÃ¶re nick valid karakter setini kontrol etmen lazÄ±m. Åu an "nick with space" bile geÃ§er.

1. Channel.cpp

AmaÃ§: KanallarÄ± (IRCâ€™de #channel) temsil ediyor.

_members: kanaldaki client FDâ€™leri.

_ops: operator olan client FD seti.

_invited: davetli kullanÄ±cÄ±lar.

_limit, _modeI, _modeT, _modeK, _modeL: kanal modlarÄ±nÄ± saklÄ±yor (invite-only, topic protected, key, limit).

Ã–nemli fonksiyonlar:

addMember(fd): kullanÄ±cÄ±yÄ± kanala ekler.

removeMember(fd): Ã§Ä±karÄ±r + ops/invite listesinden de temizler.

isMember(fd): kanalda var mÄ± kontrol.

addOp/removeOp/isOp: operator kontrolÃ¼.

invite/isInvited/revokeInvite: davet sistemi.

Yani burasÄ± tamamen kanal yÃ¶netim stateâ€™i.

2. Client.cpp

AmaÃ§: BaÄŸlanan her kullanÄ±cÄ±yÄ± temsil ediyor.

_fd: socket FD.

_ip, _port: baÄŸlantÄ± bilgisi.

_nick, _user: kullanÄ±cÄ± kimliÄŸi.

_channels: hangi kanallara Ã¼ye olduÄŸu.

_rbuf: socketâ€™ten gelen ham veri.

_wq: Ã§Ä±kÄ±ÅŸ kuyruÄŸu (mesajlar).

_passOk: PASS kontrolÃ¼ geÃ§ti mi.

Ã–nemli fonksiyonlar:

getPrefix(): IRC prefix formatÄ± dÃ¶ner nick!user@ip.

appendRead(data, n): gelen veriyi _rbufâ€™a ekler.

nextLine(out): _rbuf iÃ§inden bir satÄ±r Ã§Ä±karÄ±r (\r\n bitince).

queueWrite(msg): Ã§Ä±kÄ±ÅŸ kuyruÄŸuna mesaj ekler.

hasWrite/peekWrite/consumeWrite: Ã§Ä±kÄ±ÅŸ kuyruÄŸunu yÃ¶netir.

joinChannel(name) / leaveChannel(name): kanal listesini gÃ¼nceller.

Yani Client sÄ±nÄ±fÄ± â€œher kullanÄ±cÄ±yla ilgili state + soket IO bufferâ€.

3. main.cpp

AmaÃ§: Program giriÅŸ noktasÄ±.

argc != 3 â†’ Usage mesajÄ±.

argv[1]: port, argv[2]: password.

isNumber(port) ile port check.

Server server(port, password); server.run(); â†’ server ayaÄŸa kalkÄ±yor.

KÄ±saca parametre check + server baÅŸlatma.

4. Parser.cpp

AmaÃ§: IRC satÄ±rÄ±nÄ± Message structâ€™Ä±na Ã§eviriyor.

Trim fonksiyonu boÅŸluk/tab kÄ±rpÄ±yor.

parse(line) akÄ±ÅŸÄ±:

EÄŸer : ile baÅŸlÄ±yorsa prefix var â†’ nick!user@host.

Sonraki token â†’ command (Ã¶rn. NICK, USER, JOIN).

Geri kalanlar â†’ params. EÄŸer : ile baÅŸlÄ±yorsa, geri kalanÄ± tek parametre sayÄ±yor (Ã¶rn. mesajlar).

Parametreleri trimâ€™liyor.

SonuÃ§: Message = { prefix, command, params }.

5. Poller.cpp

AmaÃ§: poll() sistem Ã§aÄŸrÄ±sÄ± ile IO multiplexing.

_pfds: pollfd arrayâ€™i.

add(fd, events): FD ekler.

modify(fd, events): FD event maskesini deÄŸiÅŸtirir.

remove(fd): FD siler.

wait(timeout): poll Ã§aÄŸÄ±rÄ±r.

isReadable/isWritable: event kontrolÃ¼.

readables()/writables(): FD listesi dÃ¶ner.

KÄ±saca Linuxâ€™ta Ã§oklu client IOâ€™yu yÃ¶netiyor.

6. Router.cpp

AmaÃ§: Gelen Messageâ€™Ä± uygun handlerâ€™a yÃ¶nlendirmek.

PASS, NICK, USER, JOIN, PART, PRIVMSG, NOTICE, TOPIC, INVITE, KICK, MODE, QUIT, PING, LIST, NAMES, WHO, MOTD â†’ hepsi burada tek tek if zinciriyle iÅŸleniyor.

Her komutun iÃ§i client/kanal stateâ€™ini gÃ¼ncelliyor ve Server Ã¼zerinden broadcast yapÄ±yor.

BurasÄ± â€œbeyinâ€ gibi â†’ hangi komut geldi, nasÄ±l cevap verilecek.

7. Server.cpp

AmaÃ§: IRC serverâ€™Ä±n Ã§ekirdeÄŸi.

Server(port, password): soket aÃ§, bind, listen.

run(): sonsuz loop:

poller.wait() â†’ IO event bekler.

readable fdâ€™ler â†’ handleReadable(fd).

writable fdâ€™ler â†’ handleWritable(fd).

handleAccept(): yeni client kabul et, Client oluÅŸtur, pollerâ€™a ekle.

handleReadable(fd):

Clientâ€™Ä± bul.

Veri oku, appendRead.

SatÄ±r geldikÃ§e Parser::parse.

Router Ã§aÄŸÄ±r.

handleWritable(fd): kuyruÄŸu send() ile clientâ€™a gÃ¶nder.

removeClient(fd): client kapatÄ±lÄ±rken temizle.

BurasÄ± â€œmotorâ€ â†’ soket + poller + client management.

Genel Ã‡alÄ±ÅŸma AkÄ±ÅŸÄ±

main â†’ Server::run().

poll() bekler.

Yeni baÄŸlantÄ± gelirse handleAccept â†’ yeni Client.

Veri gelirse handleReadable â†’ Parser â†’ Router.

Router ilgili komutu iÅŸler â†’ Server ve Channel gÃ¼nceller.

Mesaj Ã§Ä±kÄ±ÅŸÄ± varsa â†’ queueWrite â†’ sonra handleWritable ile gÃ¶nderilir.

Ã–zet

Channel â†’ kanal state.

Client â†’ kullanÄ±cÄ± state + IO buffer.

Parser â†’ raw satÄ±r â†’ Message.

Poller â†’ IO multiplex.

Router â†’ komut yÃ¶nlendirme.

Server â†’ soket + client management.

main â†’ sadece parametre check + server baÅŸlat.

YÃ¼ksek seviye: sistem nasÄ±l Ã§alÄ±ÅŸÄ±yor?

KÄ±saca: program bir TCP dinleyici aÃ§Ä±yor, poll() ile Ã§oklu soketleri izliyor. Yeni baÄŸlantÄ± gelince Client nesnesi oluÅŸturuluyor. Soketten gelen ham veriler Client._rbuf'a ekleniyor. \r\n ile biten tam satÄ±rlar Parser tarafÄ±ndan Message nesnesine dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼yor. Router bu mesajÄ± alÄ±p komuta gÃ¶re sunucu/kanal/diÄŸer istemcilere mesaj gÃ¶nderiyor. Ã‡Ä±ktÄ±lar Client._wq kuyruÄŸuna konuyor; handleWritable kuyruÄŸu send() ile socketâ€™e boÅŸaltÄ±yor.

Dosya/komponent bazlÄ± detaylar
Channel (kanal state)

AmaÃ§: bir kanalÄ±n (Ã¶rn. #foo) Ã¼yelerini, operatÃ¶rlerini, modlarÄ±nÄ±, davetlileri tutmak.

Ã–nemli alanlar:

std::vector<int> _members â€” FD listesi

std::set<int> _ops â€” op (operator) FDâ€™leri

std::set<int> _invited â€” invite-only iÃ§in davetliler

_limit, _modeI, _modeT, _modeK vb â€” modlar / limit / key

Tipik iÅŸlemler:

addMember(fd), removeMember(fd): Ã¼yelik yÃ¶netimi

isMember(fd), isOp(fd) â€” sorgular

invite(fd), isInvited(fd), revokeInvite(fd) â€” invite-only mekanizmasÄ±

KÄ±rÄ±lma noktalarÄ± / dikkat:

removeMember vektÃ¶rden silerken indeks yÃ¶netimi Ã¶nemli; erase(begin()+i) gÃ¼venli ama std::remove+erase daha temiz.

Modlar (invite-only, key, limit) doÄŸru ÅŸekilde kontrol edilmeli â€” eÄŸer bir kanalÄ± #foo +k secret yapÄ±yorsan JOIN isteÄŸinde key kontrolÃ¼ kesin olmalÄ±.

Kanal boÅŸaldÄ±ÄŸÄ±nda nesneyi silmeyi unutma (removeChannelIfEmpty server tarafÄ±nda yapÄ±lmalÄ±).

Client (kullanÄ±cÄ± state + IO buffer)

AmaÃ§: Her baÄŸlantÄ± iÃ§in durum tutmak.

Ã–nemli alanlar:

_fd, _ip, _port â€” baÄŸlantÄ± bilgileri

_nick, _user, _real â€” kimlik bilgileri

_rbuf â€” gelen ham veri (string)

_wq â€” gÃ¶nderilecek mesaj kuyruÄŸu (vector<string>)

_channels â€” kullanÄ±cÄ±nÄ±n Ã¼ye olduÄŸu kanallar

_passOk â€” PASS doÄŸrulandÄ± mÄ±?

Ã–nemli fonksiyonlar:

appendRead(data, n) â€” recv() ile gelen veriyi _rbuf'a ekle

nextLine(out) â€” _rbuf iÃ§inde \r\n bulursa satÄ±rÄ± Ã§Ä±karÄ±p verir

queueWrite(msg), peekWrite(), consumeWrite(n) â€” Ã§Ä±kÄ±ÅŸ kuyruÄŸu yÃ¶netimi

Kritik ayrÄ±ntÄ±lar:

nextLine sadece \r\n arÄ±yor; bazÄ± istemciler \n ile gÃ¶nderebilir. (Tercih: protokol aÃ§Ä±sÄ±ndan \r\n kesin ama tolerant olmak testlerde iÅŸe yarar.)

consumeWrite: send() kÄ±smi yazma yapabilir. n dÃ¶nÃ¼ÅŸÃ¼nÃ¼ kullanÄ±p kuyruk baÅŸÄ±nÄ± uygun ÅŸekilde kÄ±rmalÄ±sÄ±n. EÄŸer send() 0 dÃ¶nerse dikkat â€” genelde socket kapandÄ±.

getPrefix() ÅŸu an nick!user@ip dÃ¶ndÃ¼rÃ¼yor; tipik uygulama host kÄ±smÄ±na hostname koyar. Testlerde IP kabul edilebilir ama RFC uyumluluÄŸu aÃ§Ä±sÄ±ndan hostname daha doÄŸru.

Parser (satÄ±rÄ± Messageâ€™a Ã§evirme)

AmaÃ§: Gelen dÃ¼z metin satÄ±rÄ±nÄ± (:prefix COMMAND params :trailing) ayrÄ±ÅŸtÄ±rmak.

Temel akÄ±ÅŸ:

EÄŸer satÄ±r : ile baÅŸlÄ±yorsa ilk token prefix (Ã¶r. :nick!user@host)

Sonraki token command (Ã¶rn. PRIVMSG, JOIN)

Geri kalanÄ± parametrelerdir; eÄŸer bir parametre : ile baÅŸlÄ±yorsa o anki parametrenin geri kalanÄ± (trailing) tek bir parametre olarak alÄ±nÄ±r.

Ã–rnek:

:nick!user@host PRIVMSG #chan :selam millet nasÄ±l gidiyor\r\n


â†’ prefix = nick!user@host, command = PRIVMSG, params = ["#chan", "selam millet nasÄ±l gidiyor"]

Senin kodunun eksikleri:

trim fonksiyonu iyi ama parse'Ä±n trailing mantÄ±ÄŸÄ± bazÄ± corner-caselerde hata verebilir (Ã¶rn. prefix varsa ama format farklÄ±ysa).

m.command bÃ¼yÃ¼k/kÃ¼Ã§Ã¼k harf dÃ¶nÃ¼ÅŸÃ¼mÃ¼nÃ¼ Ã¼st katmanda yapÄ±yorsun; sorun deÄŸil ama std::toupper kullanÄ±mÄ± gÃ¼venli cast gerektirir ((unsigned char) ile).

nextLine ile uyumlu Ã§alÄ±ÅŸÄ±r ama parametre birleÅŸtirme gÃ¼venli yapÄ±ldÄ±ÄŸÄ±ndan emin olmalÄ±sÄ±n (PRIVMSG metnini birleÅŸtirmek gibi).

Poller (I/O multiplexing)

AmaÃ§: poll() Ã§aÄŸrÄ±sÄ±nÄ± sarmak â€” hangi fd okunabilir/yazÄ±labilir.

YapÄ±lanlar:

_pfds iÃ§inde pollfd struct'larÄ±nÄ± tutuyorsun.

add, modify, remove basit map/vektor manipÃ¼lasyonlarÄ±.

wait(timeout) â†’ poll(ptr, n, timeout)

Tehlikeli yerler:

_pfds.empty() iken _pfds[0] almaya Ã§alÄ±ÅŸmak UB. Kodunda buna benzeyen bir koruma var ama daha temiz: eÄŸer _pfds boÅŸsa poll(nullptr, 0, timeout) kullan veya if empty return 0.

modify/remove gibi fonksiyonlarda fd bulunmazsa silent geÃ§iliyor â€” debug iÃ§in log atmak iyi olur.

Router (komut yÃ¶nlendirme / komut iÅŸleyici)

AmaÃ§: Message al, authorize kontrolÃ¼ yap, komuta gÃ¶re Server/Channel/Client iÅŸlemlerini yap.

Ã–rnek komut akÄ±ÅŸlarÄ±:

PASS password â€” baÄŸlanan kullanÄ±cÄ±nÄ±n ÅŸifre kontrolÃ¼

NICK nick â€” nickname ata (Ã§akÄ±ÅŸma kontrolÃ¼)

USER user mode unused realname â€” RFC gereÄŸi kaydÄ±n ikinci yarÄ±sÄ±

JOIN #chan â€” kanal join, mode/key/limit/invite kontrolÃ¼

PRIVMSG target :text â€” hedefe mesaj gÃ¶nderme (kanala broadcast veya bireye send)

MODE, KICK, INVITE, PART, QUIT, PING/PONG â€” ilgili iÅŸlemler

Ã–nemli yanlÄ±ÅŸlar/eksikler:

PRIVMSG ve TOPIC gibi komutlarda mesajÄ±n geri kalanÄ±nÄ± (: ile baÅŸlayan trailing) doÄŸru alman lazÄ±m. Sen m.params[1] diyor, ama trailing parametre birden fazla kelimeyse parse bunu tek parÃ§a yapmalÄ± veya Router birleÅŸtime yapmalÄ±.

Auth: PASS, NICK, USER Ã¼Ã§lÃ¼sÃ¼nden sonra kullanÄ±cÄ± authed() olmalÄ±. Kodda bu akÄ±ÅŸ eksik/eÅŸ zamanlÄ± hataya aÃ§Ä±k.

MODE implementation Ã§ok yÃ¼zeysel; Ã¶rn +k parametresi yoksa gÃ¼venli davranmalÄ±, +l iÃ§in non-number kontrolÃ¼ yapÄ±lmalÄ±.

YanÄ±t formatlarÄ± (:ircserv 421 <nick> <cmd> :Unknown command) RFC numericsâ€™lerine uyumlu deÄŸil â€” testler numeric bekleyebilir.

Server (soket + client yÃ¶netimi)

AmaÃ§: Dinleme socketâ€™i aÃ§mak (IPv6/IPv4), accept, read, write, client/kanal haritalarÄ±nÄ± tutmak.

Ã–nemli fonksiyonlar:

setupSocket() â€” IPv6 deniyor, baÅŸarÄ±sÄ±zsa IPv4 aÃ§Ä±yor. Non-blocking yapÄ±yor.

run() â€” poll loop, accept/read/write dÃ¶ngÃ¼sÃ¼

handleAccept() â€” accept, client oluÅŸtur, setNonBlocking, addClient

handleReadable(fd) â€” recv() dÃ¶ngÃ¼sÃ¼, appendRead, nextLine + Router.handle

handleWritable(fd) â€” kuyruÄŸu send() ile boÅŸaltma

removeClient(fd, reason) â€” client kapatÄ±p kanallardan Ã§Ä±karma

Kritik hatalar ve dÃ¼zeltmeler:

handleReadable her satÄ±r iÃ§in Router router(this); oluÅŸturuyor. Bu gereksiz overhead â€” Router stateless ise bir tane daha Ã¼stte tut, stateful ise referans ver.

handleReadable iÃ§inde recv() dÃ¶ngÃ¼sÃ¼: n==0 disconnect demek, n<0 ve errno==EAGAIN anlamÄ± â€œdaha sonra okuâ€ (normal). BunlarÄ± doÄŸru ayrÄ±ÅŸtÄ±rÄ±yorsun ama removeClient Ã§aÄŸrÄ±lmadan Ã¶nce pollerâ€™dan fdâ€™yi kaldÄ±rÄ±p close etmelisin.

handleWritable: send() her zaman bÃ¼tÃ¼n veriyi yazmayabilir (kÄ±smÃ® yazma). consumeWrite(n) buna gÃ¶re kuyruktan kalanlarÄ± bÄ±rakÄ±yor ama satÄ±r baÅŸÄ±nda if (n == 0) break; diye bir kontrol var â€” send()'in 0 dÃ¶nÃ¼ÅŸÃ¼ genelde kapalÄ± soket belirtir; dikkat. AyrÄ±ca updatePollWrite(fd) ile POLLOUTâ€™u kapatman doÄŸru, ama modify Ã§aÄŸrÄ±sÄ±nÄ±n baÅŸarÄ±lÄ± olduÄŸundan emin ol.

removeClient: kanallardan Ã§Ä±karÄ±rken broadcastToChannel Ã§aÄŸÄ±rÄ±yorsun ama eÄŸer broadcast iÃ§inde sendToClient client listesinden birini sildiriyorsa iterasyon bozulabilir. (Burada sen kopyasÄ±nÄ± alÄ±p dolaÅŸÄ±yorsun â€” iyi.)

Bir IRC mesajÄ±nÄ±n baÅŸtan sona akÄ±ÅŸÄ± (Ã¶rnek, tam adÄ±m adÄ±m)

KullanÄ±cÄ± A clientâ€™te send("PRIVMSG #deneme :selam dÃ¼nya\r\n"). TCP Ã¼zerinden sunucuya gider.

Sunucu recv() alÄ±r, Client._rbuf.append(...).

Client::nextLine \r\n bulunca satÄ±rÄ± Ã§Ä±karÄ±r â†’ line = "PRIVMSG #deneme :selam dÃ¼nya".

Parser::parse(line) Ã§alÄ±ÅŸÄ±r â†’ Message{prefix="", command="PRIVMSG", params=["#deneme", "selam dÃ¼nya"]}

Router::handle(fd, m) Ã§alÄ±ÅŸÄ±r:

Yetki kontrolÃ¼ (authed?) â†’ geÃ§erli ise

target #deneme â†’ kanal bulunur, isMember(fd) kontrol edilir

broadcast string oluÅŸturulur: ":nick!user@host PRIVMSG #deneme :selam dÃ¼nya\r\n"

Server::broadcastToChannel tÃ¼m Ã¼yelerin Client::_wq'sine queueWrite(msg) yapar (gÃ¶nderen hariÃ§).

Bir sonraki poll dÃ¶ngÃ¼sÃ¼nde o Ã¼yelerin fdâ€™si POLLOUT olarak gelir. handleWritable Ã§aÄŸrÄ±lÄ±r.

send() ile verinin bir kÄ±smÄ± ya da tamamÄ± gidilir. consumeWrite(n) ile kuyruktan Ã§Ä±karÄ±lÄ±r. EÄŸer veri kalmÄ±ÅŸsa POLLOUT aÃ§Ä±k kalÄ±r; yoksa POLLOUT kapatÄ±lÄ±r.

En kritik dÃ¼zeltmeler â€” hÄ±zlÄ± ve somut (kod-snippetâ€™ler)
1) std::toupper kullanÄ±mÄ± (gÃ¼venli cast)
for (size_t i = 0; i < m.command.size(); ++i)
    m.command[i] = static_cast<char>(std::toupper(static_cast<unsigned char>(m.command[i])));

2) PRIVMSG/trailing parametreleri doÄŸru almak (Router iÃ§inde)

Routerâ€™da std::string text = m.params[1]; kullanmak yerine:

// params: ["#chan", "mesajÄ±n tamamÄ±"] OR ["nick", "msg"]
// ama eÄŸer parse olayÄ± boÅŸluklarÄ± ayÄ±rdÄ±ysa:
std::string text;
if (m.params.size() >= 2) {
    // join tÃ¼m kalan parametreleri birleÅŸtir (Ã¶rn. bazÄ± implementasyonlarda parse
    // trailing kÄ±smÄ± tek parametre olmalÄ± ama gÃ¼venlik iÃ§in yine de birleÅŸtir)
    for (size_t i = 1; i < m.params.size(); ++i) {
        if (i > 1) text += " ";
        text += m.params[i];
    }
}

3) Parser::parse â€” trailing parametre kesinleÅŸtirme (Ã¶rnek)
// (basit pseudo)
if (pos < s.size()) {
    while (pos < s.size()) {
        if (s[pos] == ':') {
            // geri kalan tek parametre (trailing)
            m.params.push_back(s.substr(pos+1));
            break;
        }
        size_t next = s.find(' ', pos);
        if (next == std::string::npos) { m.params.push_back(s.substr(pos)); break; }
        m.params.push_back(s.substr(pos, next-pos));
        pos = next + 1;
    }
}


(Bu senin kodla bÃ¼yÃ¼k oranda aynÄ±; Ã¶nemli olan Routerâ€™da kesinleÅŸtirmek.)

4) Poller::wait gÃ¼venli kullanÄ±mÄ±
int Poller::wait(int timeoutMs) {
    if (_pfds.empty()) return 0;
    return poll(&_pfds[0], (nfds_t)_pfds.size(), timeoutMs);
}


veya POSIX'e gÃ¶re poll(nullptr, 0, timeout) gÃ¼venli ise onu kullan.

5) Server::handleReadable â€” Router reuse & safer loop

Routerâ€™Ä± dÃ¶ngÃ¼ dÄ±ÅŸÄ±nda oluÅŸtur.

recv() dÃ¶ngÃ¼sÃ¼nde maksimum okuma sonrasÄ± kÄ±r.

// Router router(this); // Server::run dÄ±ÅŸÄ±nda, veya Server field olarak
while (c->nextLine(line)) {
    router.handle(fd, line);
}

6) consumeWrite ve handleWritable dikkatleri

send() kÄ±smi yazarsa kalan segmenti koru.

EÄŸer send() -1 veriyorsa ve errno==EAGAIN/EWOULDBLOCK â†’ POLLOUT bekle, return.

EÄŸer send() == 0 â†’ genelde peer kapatmÄ±ÅŸ, removeClient Ã§aÄŸÄ±r.

Kod skeÃ§:

ssize_t n = send(fd, front.c_str(), front.size(), 0);
if (n < 0) {
    if (errno == EAGAIN || errno == EWOULDBLOCK) return;
    removeClient(fd, "Write error");
    return;
}
if (n == 0) { removeClient(fd, "Write error (0)"); return; }
c->consumeWrite((size_t)n);

Protokol uyumluluÄŸu ve RFCâ€™den dikkat edilmesi gerekenler

Mesaj maksimum uzunluÄŸu: RFC 1459 ~512 byte (CRLF dahil). Gelen uzunluklarÄ± sÄ±nÄ±rla.

Nick ve user validasyonu: geÃ§erli karakter seti ve maksimum uzunluk (Ã¶rn nick â‰¤ 9/30 karakter, sunucuna gÃ¶re deÄŸiÅŸir).

Numerics: clientâ€™lar Ã§oÄŸu olayda numeric reply bekler (001, 002, 003, 332 topic, 331 no-topic, 401 no-such-nick, 421 unknown-command vb). BunlarÄ± doÄŸru formatta dÃ¶ndÃ¼r. Format genelde :server 001 nick :Welcome ya da :server 401 nick target :No such nick.

Modes: +i invite-only, +k key, +l limit, +t topic protected, +o op. Mode deÄŸiÅŸiklikleri broadcast edilmelidir.

PING/PONG: keepalive iÃ§in doÄŸru cevap verilmeli; server ayrÄ±ca istemcilere PING atabilir.

GÃ¼venlik / robustness notlarÄ±

Input sanitization: nick veya topic iÃ§inde CR/LF olmamalÄ± â€” bunu reddet.

DoS korumasÄ±: aynÄ± IPâ€™den Ã§ok hÄ±zlÄ± baÄŸlantÄ±/mesaj limitleri koy.

Resource leaks: client silme sÄ±rasÄ±nda pollerâ€™dan fdâ€™yi Ã§Ä±karmak, close etmek, sonra delete etmek; aksi halde poll kapalÄ± fd'yi tekrar gÃ¶rebilir.

Partial writes: her zaman handleWritable iÃ§in test et.

Exception safety: new sonrasÄ± hata olursa leak olmasÄ±n â€” smart pointer kullanÄ±labilir ama 42 projeleri raw new/delete ister olabilir.

Ã–ncelikli dÃ¼zeltme listesi (hangi sÄ±rayla yap)

Parser/Router: trailing parametreyi ve PRIVMSG birleÅŸimini kesinleÅŸtir. (Ã‡Ã¼nkÃ¼ mesajlar doÄŸru gitmiyorsa testler fail olur.)

toupper cast fix. (Ã‡ok basit ama subtle crash kaynaÄŸÄ± olabilir.)

handleWritable / consumeWrite kurgusunu saÄŸlamlaÅŸtÄ±r. (Mesajlar eksik gidiyor veya deadlock oluyor.)

Poller::wait gÃ¼venliÄŸi (empty vector) ve Server::handleReadable iÃ§inde Router oluÅŸturmayÄ± kaldÄ±r.

Auth akÄ±ÅŸÄ±: PASS/NICK/USER -> authed() mantÄ±ÄŸÄ±nÄ± dÃ¼zelt. (Client register olmadan komut kabul etmeyin.)

Numerics (001â€“004, 331/332/401/404/421...) ile client uyumluluÄŸu saÄŸla.

MODE detaylarÄ± (o, k, l,..), topic deÄŸiÅŸikliklerinin broadcast formatÄ±nÄ± RFC'ye gÃ¶re fix.

# IRC Sunucusunu Ã‡ok BasitÃ§e AnlatÄ±yorum

---

## 1) Ã‡ok kÄ±sa Ã¶zet â€” Ne oluyor?

* Sunucu bir **dinleyici** aÃ§ar (TCP).
* Birisi baÄŸlanÄ±nca **Client** nesnesi yaratÄ±lÄ±r.
* Soketten gelen veriler **buf**'a (bellek) eklenir.
* Tam bir satÄ±r (`\r\n` ile biten) gelince **Parser** bu satÄ±rÄ± parÃ§alar: `prefix`, `komut`, `parametreler`.
* **Router** hangi komut olduÄŸunu gÃ¶rÃ¼r (Ã¶r. JOIN, PRIVMSG) ve gerekli iÅŸlemi yapar.
* GÃ¶nderilecek metinler **Client**'in Ã§Ä±kÄ±ÅŸ kuyruÄŸuna (write queue) konur.
* `poll()` veya `select()` ile hangi soket yazÄ±labilir/okunabilir bakÄ±lÄ±r; yazÄ±labilirse kuyruÄŸun iÃ§i gÃ¶nderilir.

---

## 2) Her parÃ§a ne iÅŸ yapÄ±yor â€” sÃ¼per sade

### Channel (Kanal)

* `#kanal` diye dÃ¼ÅŸÃ¼n. Ä°Ã§inde Ã¼yeler var.
* YapabildiÄŸi: Ã¼ye ekle/Ã§Ä±kar, op (operator) tut, davetli listesi tut, kanal modlarÄ±nÄ± tut (Ã¶r. invite-only).

### Client (KullanÄ±cÄ±)

* Her baÄŸlanan kiÅŸi iÃ§in bir obje.
* Ä°Ã§inde: socket numarasÄ± (fd), nick, kullanÄ±cÄ± adÄ±, hangi kanallarda olduÄŸu, okunan veri tamponu (`rbuf`), gÃ¶nderilecek mesaj kuyruÄŸu (`wq`).
* `nextLine()` fonksiyonu: `rbuf`'da `\r\n` gÃ¶rÃ¼nce bir satÄ±r Ã§Ä±kartÄ±r.

### Parser

* Bir satÄ±rÄ± alÄ±r: `:prefix KOMUT param1 param2 :trailing text`
* `prefix` (opsiyonel), `komut` (zorunlu), `params` (0+ adet) ayÄ±rÄ±r.
* `:trailing text` kÄ±smÄ±, parametrenin geri kalanÄ±dÄ±r (boÅŸluk iÃ§erir).

### Poller

* `poll()` sarma: hangi socket okunabilir/yazÄ±labilir kontrolÃ¼.
* Her fd iÃ§in `events` tutar (POLLIN, POLLOUT).

### Router

* Gelen `Message`'a gÃ¶re ne yapÄ±lacaÄŸÄ±nÄ± kararlaÅŸtÄ±rÄ±r.
* Ã–rneÄŸin `JOIN #a` gelirse: kanal bul / yoksa yarat, limit/key/invite kontrolÃ¼ yap, kullanÄ±cÄ±yÄ± Ã¼ye yap, op atamasÄ± yap, katÄ±lma mesajÄ± broadcast et.

### Server

* Hepsini bir araya getirir: socket aÃ§, accept, read, write, client/kanal map'lerini yÃ¶netir.

---

## 3) Basit Ã¶rnek akÄ±ÅŸ (adÄ±m adÄ±m)

1. KullanÄ±cÄ± `PRIVMSG #chat :selam dÃ¼nya` gÃ¶nderir.
2. Sunucu `recv()` ile veri alÄ±r, `Client.rbuf`'a ekler.
3. `nextLine()` satÄ±rÄ± Ã§Ä±karÄ±r: `PRIVMSG #chat :selam dÃ¼nya`.
4. `Parser` -> `command=PRIVMSG`, `params=["#chat","selam dÃ¼nya"]`.
5. `Router` gÃ¶rÃ¼r: hedef `#chat` -> `broadcastToChannel` Ã§aÄŸrÄ±lÄ±r.
6. Her Ã¼yenin `Client.wq`'sine `":nick PRIVMSG #chat :selam dÃ¼nya\r\n"` eklenir.
7. `poll()` o fd'leri yazÄ±labilir gÃ¶sterince, `Server.handleWritable` gÃ¶nderir.

---

## 4) Åimdi en basit dille sorunlar ve ne yapacaÄŸÄ±na dair kÄ±sa Ã§Ã¶zÃ¼mler

> Her madde: sorun â€” neden kÃ¶tÃ¼ â€” Ã§Ã¶zÃ¼m (kodu nasÄ±l deÄŸiÅŸtirirsin).

### A. **PRIVMSG mesajÄ±nÄ±n tamamÄ±nÄ± almÄ±yor**

* **Sorun:** Kod sadece `m.params[1]` alÄ±yor. Ama mesaj `:selam dÃ¼nya nasÄ±lsÄ±n` gibi birden fazla kelime iÃ§erir.
* **Neden kÃ¶tÃ¼:** Sadece ilk kelime gidiyor, kullanÄ±cÄ± mesajÄ± eksik gÃ¶rÃ¼nÃ¼yor.
* **Ã‡Ã¶zÃ¼m:** Router iÃ§inde parametreleri baÅŸtan sona birleÅŸtir. Ã–rnek:

  ```cpp
  std::string text;
  for (size_t i = 1; i < m.params.size(); ++i) {
      if (i > 1) text += " ";
      text += m.params[i];
  }
  ```

### B. **KomutlarÄ± uppercase yaparken hata riski**

* **Sorun:** `std::toupper` doÄŸrudan char alÄ±yor; signed char sorun Ã§Ä±karabilir.
* **Ã‡Ã¶zÃ¼m:** `m.command[i] = static_cast<char>(std::toupper(static_cast<unsigned char>(m.command[i])));`

### C. **Partial send (kÄ±smi gÃ¶nderimler) yanlÄ±ÅŸ yÃ¶netiliyor**

* **Sorun:** `send()` her zaman tÃ¼m veriyi gÃ¶ndermez. KÄ±smen gÃ¶nderirse kalan silinmemeli, ya da yanlÄ±ÅŸ hesaplanÄ±rsa veri kaybÄ± olur.
* **Ã‡Ã¶zÃ¼m:** `consumeWrite(n)` fonksiyonu kalanÄ± doÄŸru silmeli; `send()` 0 veya negatif dÃ¶nerse Ã¶zel iÅŸlem yap.

### D. **Parser doÄŸru parse etmeyebilir (trailing)**

* **Sorun:** `:` ile baÅŸlayan trailing kÄ±smÄ± doÄŸru alÄ±nmalÄ±. Kod genel hatlarÄ±yla alÄ±yor ama edge-case test et.
* **Ã‡Ã¶zÃ¼m:** `parse()` zaten `:` gÃ¶rdÃ¼ÄŸÃ¼nde geri kalanÄ± tek parametre yapÄ±yor; router'da yine birleÅŸtirme yap, gÃ¼venli tarafta ol.

### E. **Poller::wait boÅŸ vektÃ¶rde UB yapabilir**

* **Ã‡Ã¶zÃ¼m:** `if (_pfds.empty()) return 0;` veya `poll(nullptr, 0, timeout)` kullan.

### F. **Auth (REGISTER) akÄ±ÅŸÄ± eksik**

* **Sorun:** IRC'de `PASS` (opsiyonel), `NICK`, `USER` Ã¼Ã§Ã¼ tamamlandÄ±ÄŸÄ±nda kullanÄ±cÄ± register sayÄ±lÄ±r. Kodda `authed()` kontrolÃ¼ zayÄ±f.
* **Ã‡Ã¶zÃ¼m:** `Client` iÃ§inde `bool hasNick, hasUser, passOk;` tut. `authed()` = `hasNick && hasUser && (passOk || noPasswordRequired)`.

---

## 5) Hemen yapabileceÄŸin 5 hÄ±zlÄ± deÄŸiÅŸiklik (sÄ±ralÄ±)

1. Router: PRIVMSG ve TOPIC iÃ§in param birleÅŸtirme ekle. (Ã‡Ã¼nkÃ¼ en gÃ¶rÃ¼nÃ¼r hata bu)
2. Parser: `toupper` casting dÃ¼zeltmesi.
3. Poller::wait: boÅŸ kontrollÃ¼ yap.
4. Server: `Router router(this);`'Ä± dÃ¶ngÃ¼ dÄ±ÅŸÄ±na al, sÃ¼rekli yeniden oluÅŸturma.
5. Server: `removeClient` Ã§aÄŸÄ±rmadan Ã¶nce `_poller->remove(fd); close(fd); delete client;` sÄ±rasÄ±nÄ± netleÅŸtir.

---

## 6) Test etme â€” neyle test edersin?

* Lokal olarak: `telnet localhost 6667` veya `nc localhost 6667` baÄŸlan.
* Komut dizisi Ã¶rneÄŸi:

  ```
  PASS secret\r\n
  NICK bot1\r\n
  USER user 0 * :Real Name\r\n
  JOIN #deneme\r\n
  PRIVMSG #deneme :selam dÃ¼nya hosgeldiniz\r\n
  QUIT :bye\r\n
  ```
* Ä°zle: server konsolunda log varsa, client tarafÄ±nda `PRIVMSG` alan diÄŸer client'larda tam mesaj gidiyor mu?

1. #include kÄ±sÄ±mlarÄ±
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <iostream>
#include <string>
#include <vector>
#include <sstream>


Bunlar kÃ¼tÃ¼phaneler.

sys/socket.h, netinet/in.h, arpa/inet.h â†’ aÄŸ (socket) iÅŸlemleri iÃ§in.

unistd.h â†’ close() gibi Unix fonksiyonlarÄ±.

iostream, string, vector, sstream â†’ C++â€™ta yazÄ± yazmak, string tutmak, liste yapmak iÃ§in.

2. Client sÄ±nÄ±fÄ±
class Client {
public:
    int socket;
    std::string nickname;
    std::string buffer;

    Client(int sock) : socket(sock) {}
};


Bu, baÄŸlanan kullanÄ±cÄ±larÄ± temsil ediyor.

Her kullanÄ±cÄ± (client) iÃ§in:

socket numarasÄ± (socket) â†’ bilgisayar ile kullanÄ±cÄ± arasÄ±ndaki baÄŸlantÄ±.

nickname â†’ IRCâ€™de gÃ¶rÃ¼nen kullanÄ±cÄ± adÄ±.

buffer â†’ kullanÄ±cÄ±dan gelen ham mesajlarÄ± geÃ§ici tutmak iÃ§in.

3. IRCServer sÄ±nÄ±fÄ±
class IRCServer {
private:
    int serverSocket;
    std::vector<Client> clients;


Sunucunun kendisini tanÄ±mlÄ±yor.

serverSocket â†’ tek bir numara, bu sayede kullanÄ±cÄ±lar baÄŸlanÄ±yor.

clients â†’ tÃ¼m baÄŸlÄ± kullanÄ±cÄ±larÄ±n listesi (vector iÃ§inde Client).

4. start(int port)
void start(int port) {
    serverSocket = socket(AF_INET, SOCK_STREAM, 0);
    ...
}


Burada sunucu baÅŸlatÄ±lÄ±yor.

socket(AF_INET, SOCK_STREAM, 0) â†’ TCP baÄŸlantÄ±sÄ± iÃ§in yeni soket aÃ§ar.

sockaddr_in serverAddr â†’ IP ve port bilgisini tutar.

AF_INET â†’ IPv4.

INADDR_ANY â†’ hangi IPâ€™den gelirse gelsin kabul et.

htons(port) â†’ portu doÄŸru formata Ã§evirir.

bind() â†’ bu portu bilgisayara baÄŸlar.

listen() â†’ artÄ±k baÄŸlantÄ± beklemeye baÅŸlar.

5. handleConnections()

Sonsuz dÃ¶ngÃ¼ Ã§alÄ±ÅŸÄ±yor.

accept() â†’ yeni biri baÄŸlanÄ±rsa Client oluÅŸturup clients listesine ekliyor.

Sonra tÃ¼m clientâ€™leri gezip recv() ile mesaj gelmiÅŸ mi diye bakÄ±yor.

Mesaj varsa:

/nick komutu ise â†’ kullanÄ±cÄ±nÄ±n adÄ±nÄ± deÄŸiÅŸtiriyor.

DeÄŸilse â†’ herkese gÃ¶nderiyor (broadcast).

6. broadcast(message, senderSocket)
void broadcast(const std::string& message, int senderSocket) {
    for (auto& client : clients) {
        if (client.socket != senderSocket) {
            send(client.socket, message.c_str(), message.size(), 0);
        }
    }
}


Gelen mesajÄ± herkese yayar.

GÃ¶nderen hariÃ§ (if (client.socket != senderSocket)), Ã§Ã¼nkÃ¼ kendi yazdÄ±ÄŸÄ±nÄ± tekrar gÃ¶rmesin.

7. main()
int main() {
    IRCServer server;
    server.start(6667);
    return 0;
}


ProgramÄ± baÅŸlatÄ±r.

6667 â†’ klasik IRC portu.

ğŸ“Œ Ã–zet:

Program kÃ¼Ã§Ã¼k bir IRC server.

Yeni kullanÄ±cÄ± baÄŸlanÄ±nca listeye ekleniyor.

KullanÄ±cÄ± mesaj yazarsa â†’ ya nick deÄŸiÅŸtiriyor ya da mesajÄ± herkese gidiyor.

MantÄ±k Ã§ok basit bir chat odasÄ± gibi.
1. void start(int port)

Bu fonksiyon sunucuyu aÃ§Ä±yor ve baÅŸlatÄ±yor.
AdÄ±m adÄ±m:

serverSocket = socket(AF_INET, SOCK_STREAM, 0);

Yeni bir soket aÃ§Ä±lÄ±yor. (Telefon hattÄ± gibi dÃ¼ÅŸÃ¼n, bu numara Ã¼zerinden konuÅŸulacak).

AF_INET â†’ IPv4 protokolÃ¼.

SOCK_STREAM â†’ TCP baÄŸlantÄ±sÄ±.

0 â†’ protokol otomatik seÃ§.

sockaddr_in serverAddr; â†’ adres bilgilerini tutacak bir kutu.

serverAddr.sin_family = AF_INET;

Adres tipi IPv4.

serverAddr.sin_addr.s_addr = INADDR_ANY;

â€œBana hangi IPâ€™den baÄŸlanÄ±rlarsa baÄŸlansÄ±n, kabul et.â€

serverAddr.sin_port = htons(port);

Portu kÃ¼Ã§Ã¼k-bÃ¼yÃ¼k endian uyumu iÃ§in Ã§evirip yerleÅŸtiriyor.

bind(serverSocket, (struct sockaddr*)&serverAddr, sizeof(serverAddr));

Sunucunun â€œÅŸu portu dinleâ€ demesi.

listen(serverSocket, 5);

Dinleme moduna geÃ§iyor.

â€œ5 kiÅŸi aynÄ± anda baÄŸlanmayÄ± denerse sÄ±raya alâ€ demek.

handleConnections();

ArtÄ±k baÄŸlantÄ±larÄ± yÃ¶netmeye baÅŸlÄ±yor.

2. void handleConnections()

BurasÄ± sunucunun kalbi. DÃ¶ngÃ¼ iÃ§inde sÃ¼rekli Ã§alÄ±ÅŸÄ±yor.
AdÄ±mlar:

while (true) { ... } â†’ Sonsuz dÃ¶ngÃ¼ (sunucu hep aÃ§Ä±k).

accept(...) â†’ Yeni biri baÄŸlanÄ±rsa kabul ediyor.

Yeni baÄŸlanan iÃ§in Client nesnesi oluÅŸturup clients listesine ekliyor.

Sonra mevcut tÃ¼m clientâ€™leri kontrol ediyor (for (auto& client : clients)).

recv(client.socket, buffer, ...) â†’ bu clientâ€™tan mesaj var mÄ± diye okuyor.

EÄŸer <= 0 â†’ baÄŸlantÄ± kopmuÅŸ, clientâ€™i listeden Ã§Ä±karÄ±yor.

Mesaj varsa:

client.buffer += std::string(buffer, bytesReceived); â†’ parÃ§alarÄ± birleÅŸtiriyor.

EÄŸer gelen yazÄ±da "\n" varsa â†’ bu, bir mesajÄ±n sonu.

MesajÄ± satÄ±r satÄ±r iÅŸliyor (std::getline).

EÄŸer satÄ±r /nick ile baÅŸlÄ±yorsa:

KullanÄ±cÄ±nÄ±n nickâ€™i deÄŸiÅŸtirilir (client.nickname = ...).

Aksi halde:

broadcast(message, client.socket) Ã§aÄŸrÄ±lÄ±r â†’ mesaj diÄŸer tÃ¼m clientâ€™lere gider.

3. void broadcast(const std::string& message, int senderSocket)

Bu fonksiyon yayÄ±n yapÄ±yor.
AdÄ±mlar:

for (auto& client : clients) â†’ tÃ¼m kullanÄ±cÄ±larÄ± dolaÅŸ.

EÄŸer bu kiÅŸi mesajÄ± gÃ¶nderen deÄŸilse (if (client.socket != senderSocket)).

send(client.socket, message.c_str(), message.size(), 0); â†’ mesajÄ± gÃ¶nder.

KÄ±sacasÄ±: â€œAli mesaj yazarsa, Veli ve AyÅŸeâ€™ye gider; Aliâ€™ye tekrar gÃ¶nderilmez.â€

4. int main()

AdÄ±mlar:

IRCServer server; â†’ Sunucudan bir nesne yarat.

server.start(6667); â†’ Sunucuyu 6667 portunda baÅŸlat. (IRCâ€™nin default portu).

return 0; â†’ program bittiÄŸinde Ã§Ä±k.

ğŸ“Œ Genel mantÄ±k:

start() â†’ sunucuyu kurar.

handleConnections() â†’ sÃ¼rekli yeni kullanÄ±cÄ±larÄ± ve mesajlarÄ± kontrol eder.

broadcast() â†’ mesajÄ± herkese gÃ¶nderir.

main() â†’ baÅŸlat butonu gibi.
Soket nedir?

Soket, bilgisayar programÄ±nÄ±n baÅŸka bir bilgisayar veya programla haberleÅŸmesi iÃ§in aÃ§tÄ±ÄŸÄ± kapÄ± gibidir.

Yani â€œsenin programÄ±n burada dinliyor, biri gelirse konuÅŸacaÄŸÄ±zâ€ diyor.

IP + port ile tanÄ±mlanÄ±r. Ã–rnek: 127.0.0.1:6667 (localhost Ã¼zerindeki 6667 portu).

Kodda soket aÃ§ma

Senin kodda:

_listenFd = socket(AF_INET6, SOCK_STREAM, 0);


AF_INET6 â†’ IPv6 kullanacaÄŸÄ±z (modern IP).

SOCK_STREAM â†’ TCP kullanÄ±yoruz. Yani paketler sÄ±ralÄ± ve kaybolmadan gelir (UDP deÄŸil).

0 â†’ protokolÃ¼ otomatik seÃ§.

Bu fonksiyon yeni bir soket tanÄ±mlayÄ±cÄ± dÃ¶ndÃ¼rÃ¼r (_listenFd), bu da senin programÄ±n o â€œkapÄ±â€ya sahip olduÄŸunu gÃ¶sterir.

Porta baÄŸlamak
bind(_listenFd, (struct sockaddr*)&addr6, sizeof(addr6))


bind() â†’ soketi IP ve porta baÄŸlar, yani â€œbu kapÄ±yÄ± 6667 portuna koyuyorumâ€ der.

EÄŸer port doluysa veya izniniz yoksa hata verir.

Dinlemeye baÅŸlamak
listen(_listenFd, 128)


listen() â†’ â€œArtÄ±k bu kapÄ±yÄ± dinle, gelenleri sÄ±raya koy, 128 kiÅŸiye kadar bekletebilirsinâ€ der.

Bu sÄ±radaki kiÅŸiler henÃ¼z baÄŸlanmadÄ±, sadece bekliyorlar.

BaÄŸlantÄ± kabul etmek (accept)
int cfd = accept(_listenFd, (struct sockaddr*)&ss, &slen);


accept() â†’ sÄ±radaki bir client geldiÄŸinde onu alÄ±r ve yeni bir soket aÃ§ar.

_listenFd â†’ hala dinlemeye devam eder, yeni soket cfd ile gelen client ile konuÅŸur.

ArtÄ±k bu client ile okuyup yazabilirsiniz (recv/send).

Neden ayrÄ± soket?

_listenFd â†’ sadece â€œbaÄŸlanmak isteyenleri dinlerâ€, mesaj almaz.

cfd â†’ gerÃ§ek konuÅŸma soketi, sadece bu client ile ilgilenir.

Non-blocking (engellemesin)
fcntl(fd, F_SETFL, flags | O_NONBLOCK);


Normalde soket â€œbloklarâ€: recv() derse veri gelene kadar bekler.

Non-blocking â†’ veri yoksa hemen dÃ¶ner.

Bu sayede binlerce client aynÄ± anda dinlenebilir, program takÄ±lmaz.

Ã–zet

socket() â†’ kapÄ±yÄ± aÃ§ar.

bind() â†’ kapÄ±yÄ± port + IP ile etiketler.

listen() â†’ gelenleri sÄ±raya koyar.

accept() â†’ sÄ±radaki bir clientâ€™i alÄ±r ve onunla konuÅŸmaya baÅŸlar.

fcntl(..., O_NONBLOCK) â†’ bekletmeden Ã§alÄ±ÅŸÄ±r.